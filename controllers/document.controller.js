// src/controllers/documentController.js
import MedicalDocument from "../models/MedicalDocument.js";
import Transcription from "../models/Transcription.js";
import { processDocumentWithLlama } from "../services/llamaService.js";
import path from "path";
import fs from "fs";
import { errorResponse, successResponse } from "../utils/responses.js";
import { StatusCodes } from "http-status-codes";

// @desc    Upload a medical document
// @route   POST /api/documents/upload
// @access  Private
export const uploadDocument = async (req, res) => {
  if (!req.file) {
    return errorResponse(
      res,
      StatusCodes.BAD_REQUEST,
      "No file uploaded. Please select a file."
    );
  }

  try {
    const { originalname, filename, path: filePath, mimetype, size } = req.file;
    const userId = req.user.id; // Assuming protect middleware attaches user with id

    // Optional: Get other details from req.body if sent along with the file
    const { documentTitle, doctorName, documentDate } = req.body;

    const newDocument = new MedicalDocument({
      user: userId,
      originalFileName: originalname,
      storageFileName: filename, // Name generated by Multer
      filePath: filePath, // Full path where Multer saved the file
      fileType: mimetype,
      fileSize: size,
      processingStatus: "PENDING", // Initial status
      documentTitle: documentTitle || originalname.split(".")[0], // Default title from filename
      doctorName: doctorName,
      documentDate: documentDate,
    });

    const savedDocument = await newDocument.save();

    // Trigger Llama processing asynchronously (don't wait for it to finish here)
    processDocumentWithLlama(savedDocument.filePath, savedDocument)
      .then(() =>
        logger.info(
          `Llama processing initiated for ${savedDocument.originalFileName}`
        )
      )
      .catch((err) =>
        logger.error(
          `Error initiating Llama processing for ${savedDocument.originalFileName}:`,
          err
        )
      );

    return successResponse(
      res,
      StatusCodes.ACCEPTED,
      "File uploaded successfully. Processing has started.",
      {
        data: {
          id: savedDocument._id,
          originalFileName: savedDocument.originalFileName,
          uploadDate: savedDocument.uploadDate,
          processingStatus: savedDocument.processingStatus,
        },
      }
    );
  } catch (error) {
    console.error("Error uploading document:", error);
    // If file was uploaded but DB save failed, try to delete the orphaned file
    if (req.file && req.file.path) {
      fs.unlink(req.file.path, (unlinkErr) => {
        if (unlinkErr)
          console.error("Error deleting orphaned upload file:", unlinkErr);
      });
    }
    return errorResponse(
      res,
      StatusCodes.BAD_REQUEST,
      "Server error during file upload."
    );
  }
};

// @desc    Get all documents for the logged-in user
// @route   GET /api/documents
// @access  Private
export const getUserDocuments = async (req, res) => {
  try {
	  try {
    if (!req.user || !req.user.id) {
      return errorResponse(res, StatusCodes.FORBIDDEN, 'Unauthorized: User not logged in' );
    }}catch (error) {
		errorResponse(
	res,
	StatusCodes.UNAUTHORIZED,
	"Unauthorized: User not logged in"
  );
	}
    const documents = await MedicalDocument.find({ user: req.user.id })
      .sort({ uploadDate: -1 }) // Sort by newest first
      .select("-filePath -storageFileName"); // Exclude sensitive/internal paths

    return successResponse(
		res,
		  StatusCodes.OK,
		"User documents fetched successfully.",
		  { data: documents }
	);
  } catch (error) {
    console.error("Error fetching user documents:", error);
    return errorResponse(
      res,
      StatusCodes.INTERNAL_SERVER_ERROR,
      "Server error fetching documents."
    );
  }
};

// @desc    Get recent documents for the logged-in user
// @route   GET /api/documents/recent
// @access  Private
export const getRecentUserDocuments = async (req, res) => {
  try {
    const documents = await MedicalDocument.find({ user: req.user.id })
      .sort({ uploadDate: -1 })
      .limit(5) // Get latest 5 documents
      .select("-filePath -storageFileName");
    return successResponse(
      res,
      StatusCodes.OK,
      "Recent documents fetched successfully.",
      { data: documents }
    );
  } catch (error) {
    console.error("Error fetching recent documents:", error);
    return errorResponse(
      res,
      StatusCodes.INTERNAL_SERVER_ERROR,
      "Server error fetching recent documents."
    );
  }
};

// @desc    Get transcription details for a specific document
// @route   GET /api/documents/:id/transcription
// @access  Private
export const getDocumentTranscription = async (req, res) => {
  try {
    const documentId = req.params.id;
    const userId = req.user.id;

    const document = await MedicalDocument.findOne({
      _id: documentId,
      user: userId,
    });
    if (!document) {
      return errorResponse(
        res,
        StatusCodes.NOT_FOUND,
        "Document not found or access denied."
      );
    }

    const transcription = await Transcription.findOne({
      document: documentId,
      user: userId,
    });

    if (!transcription) {
      // If transcription record doesn't exist yet, it might be processing or failed without a record
      return errorResponse(res, StatusCodes.NOT_FOUND, {
        error: {
          documentId: document._id,
          originalFileName: document.originalFileName,
          processingStatus: document.processingStatus,
          message:
            document.processingStatus === "PENDING" ||
            document.processingStatus === "PROCESSING"
              ? "Transcription is still in progress."
              : "Transcription data not available. It might have failed to process.",
        },
      });
    }
    successResponse(
      res,
      StatusCodes.OK,
      "Transcription fetched successfully.",
      {
        data: {
          documentId: document._id,
          originalFileName: document.originalFileName,
          processingStatus: document.processingStatus,
          transcription: transcription.text, // Assuming transcription has a 'text' field
        },
      }
    );
    // res.json({
    //   documentId: document._id,
    //   originalFileName: document.originalFileName,
    //   processingStatus: document.processingStatus,
    //   transcription,
    // });
  } catch (error) {
    console.error("Error fetching transcription:", error);
    if (error.kind === "ObjectId") {
      return errorResponse(
        res,
        StatusCodes.BAD_REQUEST,
        "Invalid document ID format."
      );
    }
    return errorResponse(
      res,
      StatusCodes.INTERNAL_SERVER_ERROR,
      "Server error fetching transcription details."
    );
  }
};

// @desc    Get a specific document's details (metadata)
// @route   GET /api/documents/:id
// @access  Private
export const getDocumentById = async (req, res) => {
  try {
    const document = await MedicalDocument.findOne({
      _id: req.params.id,
      user: req.user.id,
    }).select("-filePath -storageFileName"); // Exclude sensitive paths

    if (!document) {
      return errorResponse(
        res,
        StatusCodes.NOT_FOUND,
        "Document not found or access denied."
      );
    }
    successResponse(
      res,
      StatusCodes.OK,
      "Document details fetched successfully.",
      { data: document }
    );
  } catch (error) {
    console.error("Error fetching document by ID:", error);
    if (error.kind === "ObjectId") {
      return errorResponse(
        res,
        StatusCodes.BAD_REQUEST,
        "Invalid document ID format."
      );
    }
    errorResponse(
	  res,
	  StatusCodes.INTERNAL_SERVER_ERROR,
	  "Server error fetching document details."
	);
  }
};

// export default {
//   uploadDocument,
//   getUserDocuments,
//   getRecentUserDocuments,
//   getDocumentTranscription,
//   getDocumentById,
// };
